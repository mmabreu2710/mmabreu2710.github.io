# Challenge "Client-side-again" Writeup

## Vulnerability: Client-Side Password Verification

### Where: JavaScript-based password verification on the client side

### Impact: This challenge demonstrates how analyzing JavaScript logic in the browser can reveal the correct password format for bypassing client-side checks.

**NOTE**: The challenge involves reconstructing the expected password by analyzing obfuscated JavaScript that verifies specific segments of the input.

## Steps to reproduce:

1. **Analyze the Obfuscated JavaScript**:
   The `verify()` function in the provided JavaScript checks different segments of `checkpass` (the input from the password field) by using `substring()` to validate individual character sequences.

2. **Reconstruct the Password**:
   By analyzing each substring check, we determined the expected password format:

   - `checkpass.substring(0, split * 2) == "picoCTF{"`
   - `checkpass.substring(7, 9) == "{n"`
   - `checkpass.substring(split * 2, split * 2 * 2) == "not_this"`
   - `checkpass.substring(3, 6) == "oCT"`
   - `checkpass.substring(split * 3 * 2, split * 4 * 2) == "_again_3"`
   - `checkpass.substring(6, 11) == "F{not"`
   - `checkpass.substring(split * 2 * 2, split * 3 * 2) == "not_this"`
   - `checkpass.substring(12, 16) == "37115}"`

   Combining each part, the password was constructed as:

   ```
   picoCTF{not_this_again_37115}
   ```

3. **Enter the Password**:
   We entered `picoCTF{not_this_again_37115}` as the password, which satisfied all the conditions in the `verify()` function.

4. **Retrieve the Success Message**:
   After entering the correct password, the page displayed the "Password Verified" message, indicating successful completion of the challenge.

## Conclusion:

By analyzing the JavaScript function used for password verification, we successfully reconstructed the required password format and completed the challenge.
